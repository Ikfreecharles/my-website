import {
  animate,
  scroll,
  hover,
} from "https://cdn.jsdelivr.net/npm/motion@latest/+esm";
// import { gsap } from "https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/gsap.min.js";
gsap.registerPlugin(ScrambleTextPlugin);

let blurbs = [
    "implement robust designs.",
    "high performance products.",
    "maintainable software.",
  ],
  curIndex = 0;

setInterval(() => {
  curIndex = (curIndex + 1) % blurbs.length;
  gsap.to(".todo", {
    scrambleText: {
      text: blurbs[curIndex],
      chars: "upperAndLowerCase",
      revealDelay: 0.1,
      tweenLength: true,
      newClass: curIndex == 2 ? "border" : "",
    },
    ease: "power2.inOut",
    overwrite: "auto",
    duration: 2,
  });
}, 5000);

const carousel = document.querySelector(".carousel__wrapper");
const carouselInner = document.querySelector(".carousel__slides");
const slides = document.querySelectorAll(".carousel__slide");
// Auto-advance system
let autoAdvanceInterval;
let userActivityTimeout;
let currentTranslateX = null;

function carouselSetup() {
  // Configuration - dynamic based on screen size
  let innerDim = window.innerWidth;
  let itemsPerSlide = innerDim < 720 ? 1 : innerDim < 1100 ? 3 : 4; // Responsive items per slide
  const totalItems = slides.length;
  let slideBy = innerDim < 720 ? 1 : 1; // How many items to advance/retreat per click

  // Function to update configuration based on screen size
  function updateConfig() {
    const isMobile = innerDim < 720;
    const isTablet = innerDim < 1100;
    itemsPerSlide = isMobile ? 1 : isTablet ? 3 : 4;
    slideBy = isMobile ? 1 : 1;
  }

  // Dynamically add clone elements
  function initializeClones() {
    const originalItems = Array.from(
      document.querySelectorAll(".carousel__slide:not(.clone)")
    );

    // Clear existing clones
    document.querySelectorAll(".clone").forEach((clone) => clone.remove());

    // Prepend clones of last items
    const lastClones = originalItems
      .slice(-itemsPerSlide)
      .map((item) => {
        const clone = item.cloneNode(true);
        clone.classList.add("clone");
        return clone;
      })
      .reverse();
    lastClones.forEach((clone) => carouselInner.prepend(clone));

    // Append clones of first items
    const firstClones = originalItems.slice(0, itemsPerSlide).map((item) => {
      const clone = item.cloneNode(true);
      clone.classList.add("clone");
      return clone;
    });
    firstClones.forEach((clone) => carouselInner.append(clone));
  }

  // Initial setup
  updateConfig();
  initializeClones();

  // Start with the first real set of images
  let currentIndex = 0; // Index of current visible center image (0 to totalItems-1)
  let position = itemsPerSlide; // Real position considering clones
  let isAnimating = false;

  // Update carousel position
  function updateCarouselPosition(animate = true) {
    if (animate) {
      carouselInner.style.transition = "transform 0.5s ease";
    } else {
      carouselInner.style.transition = "none";
    }

    const translateX = (position * -103) / itemsPerSlide;
    carouselInner.style.transform = `translateX(${translateX}%)`;
    currentTranslateX = translateX;
  }

  // Initialize position
  updateCarouselPosition(false);

  // Handle transition end
  carouselInner.addEventListener("transitionend", function () {
    isAnimating = false;
    // Handle infinite loop logic
    if (position >= totalItems + itemsPerSlide) {
      position = itemsPerSlide + (position - (totalItems + itemsPerSlide));
      updateCarouselPosition(false);
    } else if (position < itemsPerSlide) {
      position = totalItems + position;
      updateCarouselPosition(false);
    }

    currentIndex = (position - itemsPerSlide) % totalItems;
  });

  // Navigation functions
  function next() {
    if (isAnimating) return;
    isAnimating = true;
    position += slideBy;
    updateCarouselPosition();
  }

  function prev() {
    if (isAnimating) return;
    isAnimating = true;
    position -= slideBy;
    updateCarouselPosition();
  }

  // Mouse drag functionality
  let isDragging = false;
  let startX = 0;
  let startPosition = 0;

  // Prevent image drag
  const carouselArticles = document.querySelectorAll("#carouselInner article");

  carouselArticles.forEach((article) => {
    article.addEventListener("dragstart", (e) => {
      e.preventDefault();
    });
    article.style.pointerEvents = "none";
  });

  carousel.addEventListener("mousedown", startDrag);
  carousel.addEventListener("touchstart", startDrag, { passive: true });

  carousel.addEventListener("mousemove", drag);
  carousel.addEventListener("touchmove", drag, { passive: true });

  carousel.addEventListener("mouseup", endDrag);
  carousel.addEventListener("touchend", endDrag);
  carousel.addEventListener("mouseleave", endDrag);

  function startDrag(e) {
    console.log(e.target.tagName);
    if (e.target.tagName === "ARTICLE") {
      e.preventDefault();
    }

    if (isAnimating) return;

    isDragging = true;
    startX = e.type.includes("mouse") ? e.clientX : e.touches[0].clientX;
    startPosition = position;
    carousel.classList.add("dragging");
    carouselInner.style.transition = "none";
    document.body.style.cursor = "grabbing";
    document.body.style.userSelect = "none";
    registerUserActivity();
  }

  function drag(e) {
    if (!isDragging) return;

    // isAnimating = true;
    const x = e.type.includes("mouse") ? e.clientX : e.touches[0].clientX;
    const walk = ((x - startX) / carousel.offsetWidth) * itemsPerSlide;
    const newPosition = startPosition - walk;
    const translateX = (newPosition * -100) / itemsPerSlide;
    carouselInner.style.transform = `translateX(${translateX}%)`;
  }

  function endDrag(e) {
    if (!isDragging) return;

    // isAnimating = false;
    isDragging = false;
    carousel.classList.remove("dragging");
    document.body.style.cursor = "";
    document.body.style.userSelect = "";

    const x = e.type?.includes("mouse")
      ? e.clientX
      : e.changedTouches
      ? e.changedTouches[0].clientX
      : startX;
    const walk = ((x - startX) / carousel.offsetWidth) * itemsPerSlide;

    if (walk > 0.2) {
      prev();
    } else if (walk < -0.2) {
      next();
    } else {
      updateCarouselPosition();
    }
    carouselInner.style.transition = "transform 0.5s ease";
    registerUserActivity();
  }

  function startAutoAdvance() {
    clearInterval(autoAdvanceInterval);
    autoAdvanceInterval = setInterval(next, 5000);
  }

  function resetAutoAdvanceTimer() {
    clearTimeout(userActivityTimeout);
    clearInterval(autoAdvanceInterval);
    userActivityTimeout = setTimeout(startAutoAdvance, 10000);
  }

  function registerUserActivity() {
    resetAutoAdvanceTimer();
  }

  startAutoAdvance();

  carousel.addEventListener("mouseenter", () => {
    clearInterval(autoAdvanceInterval);
  });

  carousel.addEventListener("mouseleave", () => {
    resetAutoAdvanceTimer();
  });

  carousel.addEventListener("click", registerUserActivity);
  carousel.addEventListener("wheel", registerUserActivity);

  // Handle window resize
  window.addEventListener("resize", function () {
    const wasMobile = itemsPerSlide === 1;
    updateConfig();
    setCarouselHeight();

    // Only reinitialize if mobile state changed
    if (
      (wasMobile && itemsPerSlide > 1) ||
      (!wasMobile && itemsPerSlide === 1)
    ) {
      initializeClones();
      position = itemsPerSlide; // Reset position
      updateCarouselPosition(false);
    }
  });
}

function stop() {
  document.querySelectorAll(".clone").forEach((clone) => clone.remove());
  clearTimeout(userActivityTimeout);
  clearInterval(autoAdvanceInterval);
}

const observer = new IntersectionObserver(callback, { threshold: 0.1 });

function callback(entries, observer) {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      carouselSetup();
    } else {
      stop();
    }
  });
}

observer.observe(carousel);
